import re
import os
import requests
from rich.console import Console

from db.utils import get_functions_for_repo, init_session, mark_irrelevant, get_repos, classify_repo

console = Console()

LLM_MODEL = os.getenv("LLM_MODEL", "llama3.2")


def rate_relevancy(repo_id):
  init_session()
  functions = get_functions_for_repo(repo_id)

  for function in functions:
    prompt = f"""
    Based on following facts about a function:

    It is located in "{function.file_name}".
    It's name is "{function.name}".
    It's names occurring in this function are: "{function.names}"

    Do you think this function is likely to be read by humans or is it likely
    autogenerated, obfuscated or a test function? Answer -only- with "yes" or "no".
    """

    url = "http://localhost:11434/api/generate"
    payload = {
        "model": LLM_MODEL,
        "prompt": prompt,
        "stream": False,
    }

    response = requests.post(url, json=payload)

    if response.status_code == 200:
      try:
        json = response.json()['response'].lower()
        
        if "no" in json:
          mark_irrelevant(function, False)
          console.print(f"Marked {function.name} as irrelevant")
      except ValueError:
        print(f"Failed to parse response LLM")
    else:
        print(f"Request failed with status code {response.status_code}")


def rate_lexicon(repo_id):
  init_session()
  functions = get_functions_for_repo(repo_id)
  ratings = []
  num_functions = len(functions)

  for i, function in enumerate(functions):
    prompt = f"""
    Here are all names from a source-code function:

    {function.names}

    Rate lexicon (naming) quality used in this function from 1 to 5
    in terms of comprehensibility, where 1 is completely
    incomprehensible for average human and 5 is very clear and understandable.
    Very important: Respond only with a single number from 1 to 5.
    """

    url = "http://localhost:11434/api/generate"
    payload = {"model": LLM_MODEL, "prompt": prompt, "stream": False}

    response = requests.post(url, json=payload)

    if response.status_code == 200:
        json = response.json()
        try:
            rating = json['response']
            match = re.search(r'\d', rating)
            if match:
                rating = int(match.group())
            else:
                rating = None
            ratings.append(rating)
            console.print(f"({i+1}/{num_functions}) {function.name} was rated as {rating}")
        except ValueError:
          console.print(f"({i+1}/{num_functions}) {function.name} was rated as {json['response']}")
    else:
        console.print(f"Request failed with status code {response.status_code}")

  if ratings:
      mean_rating = sum(ratings) / len(ratings)
      console.print(f"Mean rating for repo {repo_id} is {mean_rating}")
      sorted_ratings = sorted(ratings)

      if num_functions % 2 == 1:
          median_rating = sorted_ratings[num_functions // 2]
      else:
          median_rating = (sorted_ratings[num_functions // 2 - 1] + sorted_ratings[num_functions // 2]) / 2
      console.print(f"Median rating for repo {repo_id} is {median_rating}")
  else:
      console.print(f"No ratings available for repo {repo_id}")

  # TODO Save to db

def read_first_20_lines(file_path):
    try:
        with open(file_path, "r") as file:
            lines = file.readlines()[:25]  # Read the first 20 lines
            return "".join(lines)  # Join the lines into a single string
    except FileNotFoundError:
        return "File not found."
    except Exception as e:
        return f"An error occurred: {str(e)}"


def classify_all_repos(only_retry=False):
  init_session()

  for repo in get_repos().all():
    if repo.readme is None:
      continue

    if only_retry and (repo.type or repo.type == 'unknown'):
      continue

    prompt = f"""
    Classify open source project "{repo.name}" written in {repo.lang} language into one of the following categories:

    - web - library related to web development or web networking
    - cli - library related to command line, such as CLI utilities, pretty printing, tools for building CLI apps
    - db - library related to databases, such as database ORMs, utilities, integrations and so on
    - ml - project related to machine learning, AI, deep learning, and so on
    - build - project is build tool, such as build system, package manager, etc
    - other - project doesn't fit into any of the above categories

    You can use a fragment of the README file (if available) to help you classify the project:
    {repo.readme}

    Don't explain your reasoning, just respond with following format: I classify this project as <type>
    """

    url = "http://localhost:11434/api/generate"
    payload = {"model": LLM_MODEL, "prompt": prompt, "stream": False}
    response = requests.post(url, json=payload)

    if response.status_code == 200:
        try:
            json = response.json()['response']
            console.print(json)
            classified_type = json.split("I classify this project as")[1].strip()

            for typ in ['web', 'cli', 'db', 'ml', 'build', 'other']:
                console.print(f'Checking if {typ} in {classified_type}')
                if typ in classified_type:
                    classify_repo(repo, typ)
                    console.print(f'Classified {repo.name} as {typ}')
                    break
        except:
            console.print(f"Failed to parse response LLM: {json}")
            classify_repo(repo, 'unknown')
    else:
        console.print(f"Request failed with status code {response.status_code}")
        classify_repo(repo, 'unknown')
