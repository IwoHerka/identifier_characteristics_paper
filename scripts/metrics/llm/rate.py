import re
import requests
from rich.console import Console

from db.utils import get_functions_for_repo, init_session, mark_irrelevant, get_repo

console = Console()


def rate_relevancy(repo_id):
  init_session()
  functions = get_functions_for_repo(repo_id)

  for function in functions:
    prompt = f"""
    Based on following facts about a function:

    It is located in "{function.file_name}".
    It's name is "{function.name}".
    It's names occurring in this function are: "{function.names}"

    Do you think this function is likely to be read by humans or is it likely
    autogenerated, obfuscated or a test function? Answer -only- with "yes" or "no".
    """

    url = "http://localhost:11434/api/generate"
    payload = {
        "model": "llama3.2:latest",
        "prompt": prompt,
        "stream": False,
    }

    response = requests.post(url, json=payload)

    if response.status_code == 200:
      try:
        json = response.json()['response'].lower()
        
        if "no" in json:
          mark_irrelevant(function, False)
          console.print(f"Marked {function.name} as irrelevant")
      except ValueError:
        print(f"Failed to parse response LLM")
    else:
        print(f"Request failed with status code {response.status_code}")


def rate_lexicon(repo_id):
  init_session()
  functions = get_functions_for_repo(repo_id)
  ratings = []
  num_functions = len(functions)

  for i, function in enumerate(functions):
    prompt = f"""
    Here are all names from a source-code function:

    {function.names}

    Rate lexicon (naming) quality used in this function from 1 to 5
    in terms of comprehensibility, where 1 is completely
    incomprehensible for average human and 5 is very clear and understandable.
    Very important: Respond only with a single number from 1 to 5.
    """

    url = "http://localhost:11434/api/generate"
    payload = {
        "model": "llama3.2:latest",
        "prompt": prompt,
        "stream": False,
    }

    response = requests.post(url, json=payload)

    if response.status_code == 200:
        json = response.json()
        try:
            rating = json['response']
            match = re.search(r'\d', rating)
            if match:
                rating = int(match.group())
            else:
                rating = None
            ratings.append(rating)
            console.print(f"({i+1}/{num_functions}) {function.name} was rated as {rating}")
        except ValueError:
          console.print(f"({i+1}/{num_functions}) {function.name} was rated as {json['response']}")
    else:
        console.print(f"Request failed with status code {response.status_code}")

  if ratings:
      mean_rating = sum(ratings) / len(ratings)
      console.print(f"Mean rating for repo {repo_id} is {mean_rating}")
      sorted_ratings = sorted(ratings)

      if num_functions % 2 == 1:
          median_rating = sorted_ratings[num_functions // 2]
      else:
          median_rating = (sorted_ratings[num_functions // 2 - 1] + sorted_ratings[num_functions // 2]) / 2
      console.print(f"Median rating for repo {repo_id} is {median_rating}")
  else:
      console.print(f"No ratings available for repo {repo_id}")

  # TODO Save to db

def read_first_20_lines(file_path):
    try:
        with open(file_path, "r") as file:
            lines = file.readlines()[:25]  # Read the first 20 lines
            return "".join(lines)  # Join the lines into a single string
    except FileNotFoundError:
        return "File not found."
    except Exception as e:
        return f"An error occurred: {str(e)}"


def classify_repo(repo_id):
  init_session()
  repo = get_repo(repo_id)

  prompt = f"""
  Classify open source project "{repo.name}" written in {repo.lang} language using a single word describing its main purpose.

  You can use a fragment of the README file (if available) to help you classify the project:
  {repo.readme}

  Don't explain your reasoning, just respond with following format: I classify this project as <type>
  """

  # prompt = f"""
  # Classify open source project "{repo.name}" written in {repo.lang} language into one of the following categories:

  # - lib/web - library related to web development or web networking
  # - lib/cli - library related to command line, such as CLI utilities, pretty printing, tools for building CLI apps
  # - lib/db - library related to databases, such as database ORMs, utilities, integrations and so on
  # - lib/ml - project related to machine learning, AI, deep learning, and so on
  # - lib/build - project is build tool, such as build system, package manager, etc
  # - other - project doesn't fit into any of the above categories

  # You can use a fragment of the README file (if available) to help you classify the project:
  # {repo.readme}

  # Don't explain your reasoning, just respond with following format: I classify this project as <type>
  # """

  console.print(prompt)

  url = "http://localhost:11434/api/generate"
  payload = {"model": "llama3.2:latest", "prompt": prompt, "stream": False}
  response = requests.post(url, json=payload)

  if response.status_code == 200:
    try:
      json = response.json()['response']
      console.print(json)
      
    except ValueError:
      print(f"Failed to parse response LLM")
  else:
      print(f"Request failed with status code {response.status_code}")